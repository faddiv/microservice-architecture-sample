import { throwException } from "./ApiException";
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class CatalogClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
      this.http = http ? http : window as any;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  catalogAll(): Promise<Product[]> {
      let url_ = this.baseUrl + "/catalog/catalog";
      url_ = url_.replace(/[?&]$/, "");

      let options_: RequestInit = {
          method: "GET",
          headers: {
              "Accept": "application/json"
          }
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processCatalogAll(_response);
      });
  }

  protected processCatalogAll(response: Response): Promise<Product[]> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
      if (status === 200) {
          return response.text().then((_responseText) => {
          let result200: any = null;
          result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Product[];
          return result200;
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<Product[]>(null as any);
  }

  /**
   * @return Created
   */
  catalogPOST(body: Product): Promise<Product> {
      let url_ = this.baseUrl + "/catalog/catalog";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: RequestInit = {
          body: content_,
          method: "POST",
          headers: {
              "Content-Type": "application/json",
              "Accept": "application/json"
          }
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processCatalogPOST(_response);
      });
  }

  protected processCatalogPOST(response: Response): Promise<Product> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
      if (status === 201) {
          return response.text().then((_responseText) => {
          let result201: any = null;
          result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Product;
          return result201;
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<Product>(null as any);
  }

  /**
   * @return Success
   */
  getProduct(id: string): Promise<Product> {
      let url_ = this.baseUrl + "/catalog/catalog/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

      let options_: RequestInit = {
          method: "GET",
          headers: {
              "Accept": "application/json"
          }
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processGetProduct(_response);
      });
  }

  protected processGetProduct(response: Response): Promise<Product> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
      if (status === 200) {
          return response.text().then((_responseText) => {
          let result200: any = null;
          result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Product;
          return result200;
          });
      } else if (status === 404) {
          return response.text().then((_responseText) => {
          return throwException("Not Found", status, _responseText, _headers);
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<Product>(null as any);
  }

  /**
   * @return Success
   */
  catalogPUT(id: string, body: Product): Promise<Product> {
      let url_ = this.baseUrl + "/catalog/catalog/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: RequestInit = {
          body: content_,
          method: "PUT",
          headers: {
              "Content-Type": "application/json",
              "Accept": "application/json"
          }
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processCatalogPUT(_response);
      });
  }

  protected processCatalogPUT(response: Response): Promise<Product> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
      if (status === 200) {
          return response.text().then((_responseText) => {
          let result200: any = null;
          result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Product;
          return result200;
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<Product>(null as any);
  }

  /**
   * @return Success
   */
  catalogDELETE(id: string): Promise<void> {
      let url_ = this.baseUrl + "/catalog/catalog/{id}";
      if (id === undefined || id === null)
          throw new Error("The parameter 'id' must be defined.");
      url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

      let options_: RequestInit = {
          method: "DELETE",
          headers: {
          }
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processCatalogDELETE(_response);
      });
  }

  protected processCatalogDELETE(response: Response): Promise<void> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
      if (status === 200) {
          return response.text().then((_responseText) => {
          return;
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  byname(name: string): Promise<Product[]> {
      let url_ = this.baseUrl + "/catalog/catalog/byname/{name}";
      if (name === undefined || name === null)
          throw new Error("The parameter 'name' must be defined.");
      url_ = url_.replace("{name}", encodeURIComponent("" + name));
      url_ = url_.replace(/[?&]$/, "");

      let options_: RequestInit = {
          method: "GET",
          headers: {
              "Accept": "application/json"
          }
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processByname(_response);
      });
  }

  protected processByname(response: Response): Promise<Product[]> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
      if (status === 200) {
          return response.text().then((_responseText) => {
          let result200: any = null;
          result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Product[];
          return result200;
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<Product[]>(null as any);
  }

  /**
   * @return Success
   */
  bycategory(category: string): Promise<Product[]> {
      let url_ = this.baseUrl + "/catalog/catalog/bycategory/{category}";
      if (category === undefined || category === null)
          throw new Error("The parameter 'category' must be defined.");
      url_ = url_.replace("{category}", encodeURIComponent("" + category));
      url_ = url_.replace(/[?&]$/, "");

      let options_: RequestInit = {
          method: "GET",
          headers: {
              "Accept": "application/json"
          }
      };

      return this.http.fetch(url_, options_).then((_response: Response) => {
          return this.processBycategory(_response);
      });
  }

  protected processBycategory(response: Response): Promise<Product[]> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
      if (status === 200) {
          return response.text().then((_responseText) => {
          let result200: any = null;
          result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Product[];
          return result200;
          });
      } else if (status !== 200 && status !== 204) {
          return response.text().then((_responseText) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          });
      }
      return Promise.resolve<Product[]>(null as any);
  }
}

export interface Product {
  id?: string | undefined;
  name?: string | undefined;
  category?: string | undefined;
  summary?: string | undefined;
  description?: string | undefined;
  imageFile?: string | undefined;
  price?: number;
}
